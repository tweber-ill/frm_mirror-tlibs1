#!./hermelin
#
# Calculate Bose factors
#

bose_n(T, E)
{
	n = 1. / (exp(E / (k_B_eVperK * T)) - 1.);
	return n;
}

bose_nplus1(T, E)
{
	n1 = bose_n(T, E) + 1.;
	return n1;
}

bose_both(T, Es)
{
	facs = vec(vec_size(Es));

	for(E : Es)
	{
		iter = cur_iter(E);

		if(E geq 0.)
			facs[iter] = bose_nplus1(T, E);
		else
			facs[iter] = bose_n(T, -E);
	}

	return facs;
}

# S(-Q, -om) / S(Q, om)
boltz(T, E)
{
	return exp(-E / (k_B_eVperK * T));
}


lorentzian(E, E0, gamma, amp)
{
	hwhm = 0.5 * gamma;
	return 1./pi * hwhm / ((E-E0)^2. + hwhm^2.) * amp;
}

gauss(E, E0, sigma, amp)
{
	return amp*exp(-((E-E0)/(sqrt(2.)*sigma))^2);
}



usage(app)
{
	print("\nBose factor calculation\n\nUsage: e.g. " + app + " T=25 Emin=0.1 Emax=5 show_peaks");
	print("\tT in K\n\tEmin in meV\n\tEmax in meV\n\tE0 in meV\n\tsigma in meV\n\tsigma_inc in meV\n");
}


main(args)
{
	if(vec_size(args) leq 1)
	{
		usage(args[0]);
		return -1;
	}

	Emin = 0.1;
	Emax = 5.;
	show_peaks = 0;
	show_bose = 1;

	E0 = 1.;
	back = 0.;
	sigma = 0.2;
	sigma_inc = 0.2;


	for(arg : args)
	{
		if(trim(arg) eq "show_peaks")
		{
			show_peaks = 1;
			continue;
		}
		if(trim(arg) eq "no_bose")
		{
			show_bose = 0;
			continue;
		}

		arg_split = trim(split(arg, "="));
		register_var(arg_split[0], real(arg_split[1]));
	}
	if(not has_var("T"))
	{
		usage(args[0]);
		print("Error: No temperature T given.");
		return -1;
	}

	strT = "T = " + T + "K";


	E = linspace(Emin*1e-3, Emax*1e-3, 128);
	b_n = bose_n(T, E);
	b_n1 = bose_nplus1(T, E);

	rel = b_n1 / b_n;

	if(show_bose)
	{
		plot([[E*1e3, b_n, ["style":"line", "legend":"<n>"]], 
			[E*1e3, b_n1, ["style":"line", "legend":"<n+1>"]]
			],

			["title" : "Bose occupation factors for " + strT, 
			"xlabel" : "E (meV)", 
			"ylabel" : "Occupation", 
			"window" : 0]);

		plot(E*1e3, rel,

			["xlabel" : "E (meV)", 
			"ylabel" : "<n+1> / <n>", 
			"style" : "line",
			"title" : "<n+1> / <n> for " + strT, 
			"window" : 1]);
	}

	if(show_peaks)
	{
		E = linspace(-Emax*1e-3, Emax*1e-3, 256);
		amp_qe = abs(bose_both(T, E) * E);

#		amp_in = abs(bose_both(T, E) * erf(E / (0.1*E0*1e-3) )^2.);
#		amp_in = erf(E / (0.3*E0*1e-3) )^2.;
#		amp_in_plus = amp_in;
#		amp_in_minus = amp_in;
		amp_in_plus = abs(bose_both(T, E) * mysteryfactor(E*1e3, E0));
		amp_in_minus = abs(bose_both(T, E) * mysteryfactor(E*1e3, -E0));

#		elast = gauss(E, 0., sigma_inc*1e-3, amp) + back*1e-3;
		elast = lorentzian(E, 0., sigma_inc*1e-3, amp_qe) + back*1e-3;
		plot(E*1e3, elast, 
			["style" : "line", 
			"xlabel" : "E (meV)", 
			"ylabel" : "Intensity", 
			"title" : "Elastic peak, sigma = " + str(sigma_inc) + " meV",
			"window" : 2]);


#		inelast = gauss(E, E0*1e-3, sigma*1e-3, amp) + gauss(E, -E0*1e-3, sigma*1e-3, amp) + back*1e-3;
		inelast = lorentzian(E, E0*1e-3, sigma*1e-3, amp_in_plus) 
				+ lorentzian(E, -E0*1e-3, sigma*1e-3, amp_in_minus) + back*1e-3;
		plot(E*1e3, inelast, 
			["style" : "line", 
			"xlabel" : "E (meV)", 
			"ylabel" : "Intensity", 
			"title" : "Inelastic peaks, sigma = " + str(sigma) + " meV, E0 = " + str(E0) + " meV",
			"window" : 3]);



#
#                inelast_nocorr = lorentzian(E, E0*1e-3, sigma*1e-3, 1.)
#                               + lorentzian(E, -E0*1e-3, sigma*1e-3, 1.) + back*1e-3;
#
#                plot(E*1e3, inelast_nocorr,
#                        ["style" : "line",
#                        "xlabel" : "E (meV)",
#                        "ylabel" : "Intensity",
#                        "title" : "Inelastic peaks (no corr.), sigma = " + str(sigma) + " meV, E0 = " + str(E0) + " meV",
#                        "window" : 4]);
#
#                inelast_nocorr = lorentzian(E, E0*1e-3, sigma*1e-3, mysteryfactor(E*1e3, E0))
#                                + lorentzian(E, -E0*1e-3, sigma*1e-3, mysteryfactor(E*1e3, -E0)) + back*1e-3;
#
#                plot(E*1e3, inelast_nocorr,
#                        ["style" : "line",
#                        "xlabel" : "E (meV)",
#                        "ylabel" : "Intensity",
#                        "title" : "Inelastic peaks (only mystery), sigma = " + str(sigma) + " meV, E0 = " + str(E0) + " meV",
#                        "window" : 5]);
#
#
#
#
#
#               inelast_nocorr_g = lorentzian(E, E0*1e-3, sigma*1e-3, 1.) * abs(E)
#                                + lorentzian(E, -E0*1e-3, sigma*1e-3, 1.) * abs(E) + back*1e-3;
#
#                plot(E*1e3, inelast_nocorr_g,
#                        ["style" : "line",
#                        "xlabel" : "E (meV)",
#                        "ylabel" : "Intensity",
#                        "title" : "Inelastic peaks (only g), sigma = " + str(sigma) + " meV, E0 = " + str(E0) + " meV",
#                        "window" : 6]);
#
#                inelast_gcorr = lorentzian(E, E0*1e-3, sigma*1e-3, amp_qe)
#                                + lorentzian(E, -E0*1e-3, sigma*1e-3, amp_qe) + back*1e-3;
#
#                plot(E*1e3, inelast_gcorr,
#                        ["style" : "line",
#                        "xlabel" : "E (meV)",
#                        "ylabel" : "Intensity",
#                        "title" : "Inelastic peaks (g corr), sigma = " + str(sigma) + " meV, E0 = " + str(E0) + " meV",
#                        "window" : 7]);
#
#
#
#		E2 = linspace(-5., 5., 256);
#		my1 = mysteryfactor(E2, E0);
#		my2 = mysteryfactor(E2, -E0);
#		plot([[E2, my1, ["style":"line"]], [E2, my2, ["style":"line"]]], 
#			["xlimits":"-5 5", "ylimits":"-1.5 1.5", "window":6]);
	}

	return 0;
}


# neuer Kugler-Weber Mysteryfaktor mit Botchkonstante b
mysteryfactor(Es, E0)
{
        b = abs(1. / (0.5 * E0));
        newE = vec(vec_size(Es));
#       print("b = " + b);
#       print("pi/b = " + pi/b);

        for(E : Es)
        {
                i = cur_iter(E);

                if(E0 greater 0.)
                {
                        if(E less 0)
                                newE[i] = 0.;
                        else
                                newE[i] = erf(b*E)^2;
                }
                else
                {
                        if(E greater 0)
                                newE[i] = 0.;
                        else
                                newE[i] = erf(b*E)^2;
                }
        }

        return newE;
}


# alter Kugler-Weber Mysteryfaktor mit Botchkonstante b
mysteryfactor_old(Es, E0)
{
	b = abs(1. / (0.25 * E0));
	newE = vec(vec_size(Es));
#	print("b = " + b);
#	print("pi/b = " + pi/b);

	for(E : Es)
	{
		i = cur_iter(E);

		if(E0 greater 0.)
		{
			if(E less 0)
				newE[i] = 0.;
			else if(E less pi/b)
				newE[i] = 0.5*(1. - cos(b*E));
			else
				newE[i] = 1.;
		}
		else
		{
                        if(E greater 0)
                                newE[i] = 0.;
                        else if(E greater -pi/b)
                                newE[i] = 0.5*(1. - cos(-b*E));
                        else
                                newE[i] = 1.;
		}
	}

	return newE;
}


